################################################################
#   ISABELLE AUGER                                             #
#                                                              #
#   isabelle.augere@mrnf.gouv.qc.ca                            #
#    last udate       July 2023                                #
#                                                              #
#                                                              #
#   Function for estimating tree volume for a list of trees    #
#                                                              #
#                                                              #
#   Use data/tarif_ass_ess.rda                                 #
#                                                              #
################################################################


#' Estimating tree volume for a list of trees in plots
#'
#' @description Estimate tree volume in dm3 with Fortin et al. (2007) equation for a list of trees in plots in a dataframe. Estimation can be deterministic or stochastic.
#'
#' @details
#' The model for tree volume estimation is a linear mixed models with species as a covariate (Fortin et al. 2007).
#' There is a random plot effect and a viree random effect. The residual errors are not correlated.
#' This function estimates volume, using deterministic parameters or stochastic parameters, for a given iteration.
#' If \code{mode_simul}='STO', the parameters must be loaded with \code{param_vol} function before using this function.
#'
#' @param fic_arbres Dataframe of trees in plots, with dhp and height, and stand info
#' \itemize{
#'    \item id_pe: identifiant unique de la placette
#'    \item dhpcm: dhp (cm) de l'arbre ou classe de dhp (>9 cm)
#'    \item essence: code d'essence de l'arbre (ex: SAB, EPN, BOP)
#'    \item no_arbre: identifiant de l'arbre ou de la combinaison dhp/essence
#'    \item hauteur_pred: hauteur de l'arbre (m)
#' }
#' @param mode_simul Simulation mode (STO = stochastic, DET = deterministic), default "DET"
#' @param iteration If \code{mode_simul}='STO, Iteration number (default 1)
#' @param parametre_vol If \code{mode_simul}='STO', Object with model parameters values, provided by \code{param_vol} function. If \code{mode_simul}='DET', the function \code{param_vol} is directly called in \code{cubage}, but \code{param_vol} can also be used.

#' @return Dataframe \code{fic_arbres} plus column vol_dm3 with volume estimation in dm3 (for one tree)
#' @export
#'
#' @examples{
#' # MODE DETERMINISTE
#' # Estimer la hauteur
#' DataHt <- relation_h_d(fic_arbres=fic_arbres_test)
#' # Estimer le volume
#' DataHtVol <- cubage(fic_arbres=DataHt)
#'
#' # MODE STOCHASTIQUE
#' # Générer les paramètres pour les modèles de hauteur et de volume pour un seul pas de simulation et plusieurs itérations
#' parametre_ht <- param_ht(fic_arbres=fic_arbres_test, mode_simul='STO', nb_iter=10)
#' parametre_vol <- param_vol(fic_arbres=fic_arbres_test, mode_simul='STO', nb_iter=10)
#' # Estimer la hauteur et le volume pour l'itération 2
#' DataHt <- relation_h_d(fic_arbres=fic_arbres_test, mode_simul='STO', iteration=2, parametre_ht=parametre_ht)
#' DataHtVol <- cubage(fic_arbres=DataHt, mode_simul='STO', iteration=2, parametre_vol=parametre_vol)
#'
#' # MODE STOCHASTIQUE
#' # Générer les paramètres pour les modèles de hauteur et de volume pour plusieurs pas de simulation et plusieurs itérations
#' parametre_ht <- param_ht(fic_arbres=fic_arbres_test, mode_simul='STO', nb_iter=10, nb_step=5)
#' parametre_vol <- param_vol(fic_arbres=fic_arbres_test, mode_simul='STO', nb_iter=10)
#' # Estimer la hauteur et le volume pour l'itération 2 et le pas de simulation 3
#' DataHt <- relation_h_d(fic_arbres=fic_arbres_test, mode_simul='STO', iteration=2, step=3, parametre_ht=parametre_ht)
#' DataHtVol <- cubage(fic_arbres=DataHt, mode_simul='STO', iteration=2, parametre_vol=parametre_vol)
#'
#' # MODE STOCHASTIQUE
#' # Estimer la hauteur et le volume de tous les arbres pour toutes les itérations et tous les pas de simulation
#' # Générer les paramètres des modèles de hauteur et de volume pour toutes les itérations et time steps
#' parametre_ht <- param_ht(fic_arbres=fic_artemis, mode_simul='STO', nb_iter=nb_iter, nb_step=nb_step)
#' parametre_vol <- param_vol(fic_arbres=fic_artemis, mode_simul='STO', nb_iter=nb_iter)
#' # Appliquer les modèles de hauteur et de volume à chaque iteration/step
#' tic()
#' fic_artemis_final1 <- NULL
#' for (i in 1:nb_iter){
#'   for (k in 1:nb_step){
#'       ht <- relation_h_d(fic_arbres=fic_artemis[fic_artemis$iter==i & fic_artemis$step==k,], mode_simul='STO', iteration=i, step=k, parametre_ht=parametre_ht)
#'       vol <- cubage(fic_arbres=ht, mode_simul='STO', iteration=i, parametre_vol=parametre_vol)
#'       fic_artemis_final1 <- bind_rows(fic_artemis_final1, vol)
#'       }
#'    }
#' toc()
#' # 52.60 sec elapsed
#'
#' # On peut aussi paralléliser les deux boucles for
#' registerDoFuture()
#' plan(multisession)
#' tic()
#' fic_artemis_final2 <- bind_rows(
#'   foreach (i = 1:nb_iter) %:% # nesting operator
#'       foreach (k = 1:nb_step) %dopar% {
#'             fic <- relation_h_d(fic_arbres=fic_artemis[fic_artemis$iter==i & fic_artemis$step==k,], mode_simul='STO', iteration=i, step=k, parametre_ht=parametre_ht)
#'             fic <- cubage(fic_arbres=fic, mode_simul='STO', iteration=i, parametre_vol=parametre_vol)
#'             }
#'  )
#' toc()
#' # 10.19 sec elapsed
#' }
cubage <- function (fic_arbres, mode_simul='DET', iteration=1, parametre_vol=NULL){

  #fic_arbres=DataHt; iteration=1; mode_simul='STO'; parametre_vol=parametre_vol;

  # si mode déterministe et que parametre_vol est vide, générer les paramètres
  if (mode_simul=='DET' &  length(parametre_vol)==0){
    parametre_vol <- param_vol(fic_arbres=fic_arbres, mode_simul='DET')
  }

ii <- iteration

# paramètres générés par la fct stochastique
param_tarif_tr <- parametre_vol[[ii]]$effet_fixe %>%  dplyr::select(-iter)

# association des essences aux essences du tarif de cubage (tarif_ass_ess.rda)
Essences_Volume <- tarif_ass_ess

arbre_vol <- fic_arbres %>% left_join(Essences_Volume, by="essence")

# Ajout des paramètres du tarif au fichier des arbres
arbre_vol2 <- left_join(arbre_vol, param_tarif_tr, by="essence_volume")

if (mode_simul=='STO'){
  random_plot <- parametre_vol[[ii]]$random_placette %>% dplyr::select(-iter) # un effet aléatoire de placettes pour tous les arbres de la placette
  resid <- parametre_vol[[ii]]$erreur_residuelle %>% dplyr::select(-iter) # une erreur résiduelle par arbre, selon l'essence (en colonne)
  # ajouter de l'effet aléatoire de placette à tous les arbres
  arbre_vol2a <- left_join(arbre_vol2, random_plot, by="id_pe")

  # ajouter de l'erreur résiduelle à chaque arbre et créer la variable resid  qui accueillera l'erreur de la bonne essence
  arbre_vol2b <- left_join(arbre_vol2a[c("id_pe","no_arbre","essence_volume")], resid, by= c("id_pe","no_arbre")) %>% mutate(resid=0)

  # garder la colonne de l'erreur residuelle de l'essence
  liste_ess <- unique(Essences_Volume$essence_volume) # liste des essences
  for (ess in liste_ess) {
   arbre_vol2b$resid[which(arbre_vol2b$essence_volume==ess)] <- as.matrix(arbre_vol2b[which(arbre_vol2b$essence_volume==ess),][ess])
  }
  arbre_vol2c <- inner_join(arbre_vol2a, arbre_vol2b[c("id_pe","no_arbre","resid")], by=c("id_pe","no_arbre")) %>% mutate(resid = as.numeric(resid))
}
else{
  arbre_vol2c <- arbre_vol2 %>% mutate(random_plot=0, resid=0)
}

# Calcul du volume

# volume en dm3;
# dhp en cm;
# hauteur en m;
# dres=1 pour résineux;
# ht_dhp = hauteur_pred/dhp;
# cylindre = pi*dhp**2*hauteur_pred/40;
# vol = -b1 x ht_dhp + (b2m + b3m*dres*dhp)*cylindre (mais le négatif est déjà appliqué au b1)

arbre_vol3 <- arbre_vol2c %>%
  mutate(
    dres = ifelse(essence_volume %in% c('EPB','EPN','EPR','MEL','PIB','PIG','PIR','PRU','SAB','THO'), 1, 0),
    cylindre = (pi * dhpcm*dhpcm * hauteur_pred)/40,
         ht_dhp = hauteur_pred/dhpcm,
         vol_dm3 = b1*ht_dhp + (b2+b3*dres*dhpcm)*cylindre + random_plot + resid) %>%
  dplyr::select(-cylindre, -ht_dhp, -essence_volume, -b1,-b2,-b3, -random_plot, -resid, -dres)
# ça donne des NA pour tous les NC (il y a certain NC qui avait une hauteur, comme le PRP, mais n'ont pas de volume, ok)

return (arbre_vol3)
}






