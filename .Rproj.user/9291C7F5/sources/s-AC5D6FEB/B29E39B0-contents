################################################################
#   ISABELLE AUGER                                             #
#                                                              #
#   isabelle.augere@mrnf.gouv.qc.ca                            #
#    last udate       July 2023                                #
#                                                              #
#                                                              #
#   Function generating parameter values of tree height model  #
#                                                              #
#   Use                                                        #
#   ht_param_fixe.rda                                          #
#   ht_param_cov.rda                                           #
#   ht_param_random.rda                                        #
#   ht_liste_ess.rda                                           #
#                                                              #
################################################################


#' Generating parameters of the total tree height model from Auger (2016)
#'
#' @description Generate parameters of the tree height model from Auger (2016), deterministic or stochastic, for each tree of each plot and for all iterations
#'
#' @details
#' The tree height estimation model is a linear mixed model calibrated per species (Auger 2016). There is a random plot effect, correlated residual errors with CorCar1 correlation fonction,
#' and a covariance matrix of fixed effects.
#'
#' @param fic_arbres Dataframe with trees for which height must be estimated, at least tree ID (no_arbre) and plot Id (id_pe) must be present
#' @param mode_simul Simulation mode (STO = stochastic, DET = deterministic), default "DET"
#' @param nb_iter Number of iteration if stochastic mode (default 1), ignored if \code{mode_simul="DET"}
#' @param nb_step Number of time steps for which we need height estimation for the same tree (default 1), ignored if \code{mode_simul="DET"}
#' @param dt Lenght of time step if nb_step>1 (default 10), ignored if \code{mode_simul="DET"}
#' @param seed_value Optionnal parameter to set the seed value for random number generation. Usually used for testing for reproductibility
#'
#' @return A list of lists, one list per species for which there is a tree height model, and for each species, a list with 4 elements:
#' \enumerate{
#'   \item essence: string with species code name
#'   \item effet_fixe: dataframe of fixed effect parameter values (one line per iteration)
#'   \item random_placette: dataframe of random plot effect values (one line per plot per iteration)
#'   \item erreur_residuelle: dataframe of residual error values (one line per tree per iteration per time step)
#' }
#' @export
#'
#' @examples{
#' # Mode déterministe
#' parametre_ht_dhp <- param_ht(fic_arbres=fic_arbres_test)
#'
#' # Mode stochastique, pour un seul pas de simulation et 10 itérations
#' parametre_ht_dhp <- param_ht(fic_arbres=fic_arbres_test, mode_simul='STO', nb_iter=10)
#'
#' # Mode stochastique, plusieurs pas de simulation et plusieurs itérations
#' parametre_ht_dhp <- param_ht(fic_arbres=fic_arbres_test, mode_simul='STO', nb_iter=10, nb_step=5)
#'  }
param_ht <- function(fic_arbres, nb_iter=1, mode_simul='DET', nb_step=1, dt=10, seed_value=NULL){

  if (length(seed_value)>0) {set.seed(seed_value)}

  #print("debut param_ht()")
  #fic_arbres=fic_arbres; nb_iter=10; mode_simul='STO'; nb_step=1; dt=10;

  # liste des arbres
  liste_arbre <- fic_arbres %>% dplyr::select(id_pe, no_arbre) %>% unique()
  # liste des placettes
  liste_place <- unique(fic_arbres$id_pe)

  # faire une essence à la fois et les mettre dans des listes: une liste de listes
  tous <- list()
  for (ess in ht_liste_ess) {
    #ess='BOJ'

    # lecture des effets fixes pour l'essence
    # fichier rda ht_param_fixe
    param2_tr <- ht_param_fixe[[ess]] %>% dplyr::select(-essence)
    #print(param2_tr)
    # liste des placettes x nb_iter pour accueillir les effets aléatoire de placette
    data_plot <- expand_grid(iter = 1:nb_iter, id_pe = liste_place)
    # liste des arbres x nb_iter pour accueillir les erreurs résiduelles
    data_arbre <- as.data.frame(unclass(expand_grid(iter = 1:nb_iter, liste_arbre)))

    if (mode_simul=='STO') {
      # lecture des matrices de covariances des effets fixes de l'essence
      covparam <- ht_param_cov[[ess]]
      covparam$essence <- NULL

      # générer une série de paramètres d'effets fixes, une par itération par essence, qui sera utilisée pour tous les arbres de cette essence de toutes les placettes
      # il faut donc autant de séries qu'il y a d'itérations, les itérations sont en lignes, les effets fixes en colonne
      param_ht = as.data.frame(matrix(mvrnorm(n = nb_iter,
                                              mu = as.matrix(param2_tr),
                                              Sigma = as.matrix(covparam)
                                              ),
                                      nrow=nb_iter))
      #print(param_ht)
      names(param_ht) <- names(param2_tr)
      param_ht <- param_ht %>%
        mutate(iter = row_number(), essence=ess)

      # fichier des effets aléatoires, corrélation et erreur résiduelle
      #ess<-'EPN'
      rand_ht <- ht_param_random[ht_param_random$essence==ess,] %>% dplyr::select(-essence)

      # générer un effet aléatoire de placette qui va s'appliquer sur le paramètre associé à ldhp2, le même pour tous les arbres de la placette
      # il faut donc autant d'effet aléatoire qu'il y a de placettes x nb_iter
      std <- sqrt(rand_ht[rand_ht$CovParm=='ldhp2' & rand_ht$Subject=="placette", 1])
      if (length(std$estimate)>0) { random_ldhp2 = as.data.frame(rnorm(nb_iter*length(liste_place), mean=0, sd = as.matrix(std))) }
      else{random_ldhp2 = as.data.frame(rep(0, nb_iter*length(liste_place)))} # le SAB n'a pas d'effet aléatoire
      #print(random_ldhp2)
      names(random_ldhp2) <- 'random_ldhp2'
      rand_plot = bind_cols(data_plot,random_ldhp2) %>% mutate(essence=ess)

      # générer une erreur résiduelle à l'échelle de l'arbre, donc autant de ligne que d'arbres  * nb_iter * time step
      std_res = sqrt(rand_ht[rand_ht$CovParm=='Residual', 1])$estimate  # ecart-type residuel
      rho = rand_ht[rand_ht$CovParm=='SP(POW)', 1]$estimate  # corrélation temporelle
      # fonction pour générer un element de la matrice de var-cov
      f <- function(i, j, std_res, rho, dt) { std_res^2 * rho^(abs(j-i)*dt) } # correlation sp(pow)
      # remplir la matrice de var-cov
      varcov = expand.grid(i=1:nb_step, j=1:nb_step)
      varcov = matrix(f(varcov$i, varcov$j, std_res, rho, dt), nrow=nb_step)
      n_arbre=length(liste_arbre$no_arbre)
      res_arbre = as.data.frame(matrix(mvrnorm(n=nb_iter*n_arbre, mu=rep(0,nb_step), Sigma = varcov), nrow=nb_iter*n_arbre))
      res_arbre = as.data.frame(bind_cols(data_arbre,res_arbre))
      # transposer les erreurs res pour avoir les time step en ligne
      res_arbre <- res_arbre %>%
        group_by(iter,id_pe) %>%
        pivot_longer(cols=contains('V'), names_to = "step", values_to = 'res_arbre') %>%
        mutate(step=as.numeric(substr(step,2,2))) %>%
        ungroup()
      #names(res_arbre) = c('iter',names(liste_arbre),'res_arbre')
      res_arbre$essence <- ess
    }
    else{
      # si mode déterministe
      param_ht <- param2_tr %>% mutate(iter=1, essence=ess)
      rand_plot <- 0
      res_arbre <- 0
    }
    temp <- list('essence'=ess, 'effet_fixe'=param_ht, 'random_placette'=rand_plot, 'erreur_residuelle'=res_arbre)
    tous <- append(tous, list(temp))
  }
  names(tous) <- ht_liste_ess
  return(tous)
}

